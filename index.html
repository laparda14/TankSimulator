<!DOCTYPE html>
<html>
<head>
<title>TinyTanks.us</title>
<link rel="shortcut icon" href="https://raw.githubusercontent.com/CrazyMeowCows/TankSimulator/main/favicon.ico">
</head>


<body>
<canvas id="canvas" width="0" height="0"></canvas>    
</body>
<script src="https://code.jquery.com/jquery-2.1.0.js"></script>
    
<script>   
//Canvas Setup and sizing
var canvas = document.getElementById('canvas'),
ctx = canvas.getContext("2d", { willReadFrequently: true });

canvas.width = Math.max(window.innerWidth-16, 1096);    
canvas.height = Math.max(window.innerHeight-21, 550);    
    
const w = canvas.width;
const h = canvas.height;    
    
//Constants
const pi = Math.PI; //Pi
const loop = 20; //Game loop speed (Ms)
const offset = 7; //Terrain height offset
const r = 30; //Cloud Radius
const Fg = -500; //Force of gravity
const year = new Date().getFullYear();
const objFg = 1;
const maxPlayerHealth = 200;
const difficulty = [{"speedModifier": 1.2, "damageModifier": 1.3, "forceSpawn": 1000, "crateChance": 9000}, {"speedModifier": 1, "damageModifier": 1, "forceSpawn": 700, "crateChance": 12000}, {"speedModifier": 1, "damageModifier": 0.7, "forceSpawn": 600, "crateChance": 14000}];
const tips = ["Make sure to stop to shoot accurately", "Get ammo by killing enemy tanks", "Tanks create a large explosion when killed", "HE shells are slow and deal splash damage", "AP shells are fast but require more accuracy", "Use your artillery strikes wisely", "The higher your score, the more coins you earn!"]

var gameState = "menu";
    
//Terrain Definitions and Setup
var tMomentum = 0;
var tY = h/2;
var forceSpawnTank = 0;
var forceSpawnCrate = 0;
var terrain = [];
for (x = 0; x < (w+100); x++) {
    generatePoint(false);
}
const grd = ctx.createLinearGradient(0,200,0,h); //Create gradient for the dirt
grd.addColorStop(0,"saddlebrown");
grd.addColorStop(1, `rgb(102, 51, 0)`);
    
//Cloud Definitions and Setup    
var clouds = [];
for (c = 0; c < 7; c++) {
    generateCloud(true, true);
}
var dayTime = Math.random();
    
//Particle Definitions
var particles = [];

//HUD Definitions
var hudValues = {health:null, ammo:null};    
var score = 0;
var topScore = getCookie("highScore", 0, true);
var coins = getCookie("coins", 0, true);
var tipIndex = getCookie("tipindex", 0, true);
var currentDiff = getCookie("difficulty", 1, true);
const diffIndex = ["Easy", "Med", "Hard"];
var displayControls = false;
    
if (performance.navigation.type == performance.navigation.TYPE_RELOAD) {
    tipIndex += 1;
    if (tipIndex >= tips.length) {tipIndex = 0;}
    setCookie("tipindex", tipIndex);
}    

//Ballistic Definitions
var shells = [];
var artilleryMode = false;
var artilleryCooldown = 0;
const artilleryRecharge = 120; //Seconds between available arty strike    
    
//Image Definitions
const earthtoneTankImg = new Image();
earthtoneTankImg.src = "https://raw.githubusercontent.com/CrazyMeowCows/TankSimulator/main/EarthtoneTank.png";
earthtoneTankImg.crossOrigin = "Anonymous";
const camoTankImg = new Image();
camoTankImg.src = "https://raw.githubusercontent.com/CrazyMeowCows/TankSimulator/main/CamoTank.png";
camoTankImg.crossOrigin = "Anonymous";
const redTankImg = new Image();
redTankImg.src = "https://raw.githubusercontent.com/CrazyMeowCows/TankSimulator/main/RedTank.png";
redTankImg.crossOrigin = "Anonymous";
    
var skinIndex = getCookie("selectedSkin", 0, true);
const skins = [earthtoneTankImg, camoTankImg, redTankImg];       

var aiTankImg = new Image();
aiTankImg.src = "https://raw.githubusercontent.com/CrazyMeowCows/TankSimulator/main/EarthtoneTank.png";
aiTankImg.crossOrigin = "Anonymous";

const healthCrate = new Image();
healthCrate.src = "https://raw.githubusercontent.com/CrazyMeowCows/TankSimulator/main/HealthCrate.png";
healthCrate.crossOrigin = "Anonymous";
const coin = new Image();
coin.src = "https://raw.githubusercontent.com/CrazyMeowCows/TankSimulator/main/CoinIcon.png";
coin.crossOrigin = "Anonymous";   
const keyboard = new Image();
keyboard.src = "https://raw.githubusercontent.com/CrazyMeowCows/TankSimulator/main/KeyboardIcon.png";
keyboard.crossOrigin = "Anonymous";   
const keybinds = new Image();
keybinds.src = "https://raw.githubusercontent.com/CrazyMeowCows/TankSimulator/main/Keybinds.png";
keybinds.crossOrigin = "Anonymous";  
    
//Object Definitions
var objects = [];
    
//Tank Definitions
var tanks = [];
var shellType = "HE"
var power = 1;
var speed = 2;
    
//Audio Definitions
var tankFireSrc = 'https://github.com/CrazyMeowCows/TankSimulator/blob/main/TankFire.mp3?raw=true';
var tankExplodeSrc = 'https://github.com/CrazyMeowCows/TankSimulator/blob/main/TankExplode.mp3?raw=true';
var shellImpact = 'https://github.com/CrazyMeowCows/TankSimulator/blob/main/ShellImpact.mp3?raw=true';
var mute = (getCookie("muted", false, false) == "true");
var sounds = [];

//Defining buttons and referencing them in an array to loop through    
var centerRestart = new Button(w/2-130, h/2+60, 130*2, 70, false, restart, drawCenterRestart);
var bottomRightPause = new Button(w-80, h-80, 70, 70, false, pause, drawBottomRightPause);
var bottomRightRestart = new Button(w-280, h-80, 270, 70, false, restart, drawBottomRightRestart);
var bottomLeftMenu = new Button(10, h-80, 300, 70, false, toggleMenu, drawBottomLeftMenu);
var centerPlay = new Button(w/2-200, h/2-150, 400, 110, true, toggleMenu, drawCenterPlay);
var artillery = new Button(10, h-80, 70, 70, false, playerAtrillery, drawAtrillery);
var centerPausedResume = new Button(w/2-230, h/2-60, 230*2, 120, false, pause, drawCenterPausedResume);
var shellSelectHE = new Button(10, 100, 70, 70, false, selectHE, drawShellSelectHE);
var shellSelectAP = new Button(10, 180, 70, 70, false, selectAP, drawShellSelectAP);
var pausedMute = new Button(10, 80, 70, 70, false, toggleMute, drawPausedMute);
var menuMute = new Button(10, 10, 70, 70, true, toggleMute, drawMenuMute);
var diffRight = new Button(w/2+100, h/2-15, 40, 50, true, incDiff, drawRightDiff);
var diffLeft = new Button(w/2-140, h/2-15, 40, 50, true, decDiff, drawLeftDiff);
var skinRight = new Button(w/2+100, h/2+75, 40, 50, true, incSkin, drawRightSkin);
var skinLeft = new Button(w/2-140, h/2+75, 40, 50, true, decSkin, drawLeftSkin);
var controlsMenu = new Button(10, 90, 70, 70, true, toggleDisplayControls, drawMenuControls);
var menuBack = new Button(10, h-80, 70, 70, false, toggleDisplayControls, drawMenuBack);

const buttons = [centerRestart, bottomRightPause, bottomLeftMenu, centerPlay, artillery, centerPausedResume, shellSelectHE, shellSelectAP, pausedMute, menuMute, diffRight, diffLeft, skinRight, skinLeft, controlsMenu, menuBack, bottomRightRestart];
    
//Keyboard Inputs
const keyNames = {32: "space", 68: "right", 39: "right", 65: "left", 37: "left", 87: "up", 38: "up", 83: "down", 40: "down", 16: "shift", 69: "increase", 33: "increase", 81: "decrease", 34: "decrease", 80: "pause", 
                  9: "tab", 82: "selectUp", 70: "selectDown"};
var keys = {"space": false, "right": false, "left": false, "up": false, "down": false, "shift": false};
var key = null;
            
$("body").keydown(function (event) {
    key = keyNames[event.keyCode] //Turns keycode into string using lookup table
    keys[key] = true; //Set keys true when they are pressed
    
    if (gameState == "running" || gameState == "paused") {
        if (gameState != "paused") {
            if (key == "increase" && power < 1.3){power += 0.3;} //Default power is 1
            if (key == "decrease" && power > 0.7){power -= 0.3;}
            
            if (key == "selectUp"){shellType = "HE";}
            if (key == "selectDown"){shellType = "AP";}
        }
        if (key == "pause") {pause();}
    }
});   
    
$("body").keyup(function (event) {
    key = keyNames[event.keyCode]
    keys[key] = false;
});  

//Mouse input for artillery
var mouseX = w/2;
var mouseY = h/2;
canvas.onmousemove = (function (event) {
    if (gameState != "paused"){
        mouseX = event.pageX-8;
        mouseY = event.pageY-8;
    }
});
//End of Initial File--------------------------------------------------------------------------------------------------    
    
//Utilities------------------------------------------------------------------------------------------------------------
//Easy Circle Drawing
function circle(x, y, r, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, pi*2, false);
    ctx.fill();
}

//Easy Line Drawing
function line(x, y, x2, y2, color, width) {
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}
   
//Return distance between two points
function getDist(x1, y1, x2, y2) {
    return Math.hypot(x2-x1, y2-y1);
}

//Get random value between min and max
function rand(min, max) {
    return Math.random() * (max - min) + min;
}

function getCookie (target, defaultValue, isNumber) {
    let segments = document.cookie.split(";");
    for (i = 0; i < segments.length; i++) {
        if (segments[i].includes(target)) {
            let targetString = segments[i].substring(segments[i].indexOf("=")+1);
            
            if (isNumber) {return Math.ceil(parseInt(targetString));}
            else {return targetString;}
        }
    }
    return defaultValue;
}

function setCookie (name, value) {
    document.cookie = name+"="+value+"; expires=Thu, 01 Jan "+(year+100)+" 00:00:00 UTC; path=/";
}    
    
//Ballistics-----------------------------------------------------------------------------------------------------------
//Shell Handling
function Shell (x, y, angle, vel, explosionRadius, damage, damageRadius, delay) {
    this.xPos = x;
    this.yPos = y;
    this.xInit = x;
    this.yInit = y;
    this.velX = vel*Math.cos(-angle);
    this.velY = vel*Math.sin(-angle);
    this.time = 0;
    this.explosionR = explosionRadius;
    this.damage = damage;
    this.damageRadius = damageRadius;
    this.queueDelay = delay;
}

function shellHandler () {
    shells.forEach(shell => {
        if (shell.queueDelay <= 0) {
            let x = shell.xPos;
            let y = shell.yPos;
            let xInit = shell.xInit
            let r = shell.explosionR;

            let Vx = shell.velX;
            let Vy = shell.velY-Fg*shell.time;

            let color = ctx.getImageData(x, y, 1, 1).data; //Get pixel data for the center of the shell, before the shell itself is drawn
            let red = color[0];
            let green = color[1];
            let blue = color[2];    
            let white = (red + green + blue) >= 450;
            let scale = Math.max(1-dayTime, 0.7);
            let sky = getSkyColor();
            if (!(red == sky[0] && green == sky[1] && blue == sky[2]) && !white && y > 1) { //Detect if shell is not in the sky (hit something)
                craterMath(x, y, r, 10);
                playAudio(shellImpact);
                explosions.push(new Explosion(x, y, r, 2)); //Create explosions based off shell explosion radius on hit
                tanks.forEach(tank => {
                    let effectiveDist = Math.max(getDist(tank.x, tank.y, x, y)-shell.damageRadius, 0); //Calculate effective distance based off damage radius
                    let modifier = difficulty[currentDiff]["damageModifier"]
                    if (tank.constructor.name == "playerTank") {modifier = 2-modifier;}
                    let damage = Math.max(shell.damage-effectiveDist, 0)*modifier
                    if (damage > 0) {
                        tank.health -= damage; //Damage tanks based on proximity to shell hit
                        objects.push(new txtObject("damage", tank.x+tank.w/2, tank.y-20, 50, 50, 4, -4, false, "-" + Math.ceil(damage), "red", 25));
                    }
                });
                for (a = 0; a <= pi; a += pi/10) {
                    particles.push(new Particle(x, y, a, Math.random()*10, "black", 5, 5, true)); //Draw hemispere of shrapnel from shell hit
                }

                shells.splice(shells.indexOf(shell), 1); //Removes shell from the array
            }

            if (gameState != "paused") {
                shell.xPos += Vx/50;
                shell.yPos += Vy/50;
                shell.time += (loop/1000);
            }

            circle(shell.xPos, shell.yPos, 5, "black");
        }
        else {
            if (gameState != "paused"){
                shell.queueDelay--;
            }
        }
    });   
    
    if (artilleryMode) {
        artilleryCooldown = 1;
    }
    else if (gameState == "running" && artilleryCooldown > 0) {
        artilleryCooldown -= 1/(artilleryRecharge*1000/loop);
    }
}

//Making explosion craters
function craterMath (x, y, r, offset) {
    for (explosionX = Math.round(x-r); explosionX <= x+r; explosionX++) { //Loop through x values within explosion radius
        let explosionY = y+Math.sqrt(r*r-(explosionX-x)*(explosionX-x)); //Calculate third side of triangle (crater depth) using y^2 = r^2 - x^2 and add that to the y value of the shell
        explosionY -= offset; //Offset crater height to make it more shallow
        explosionY = Math.min(h-20, explosionY); //Set max depth for crater so it cannot clip through bottom of the map
        if (terrain[explosionX] < explosionY) { //Check is terrain is higher than crater height
            terrain[explosionX] = explosionY; //If so, set terrain to new height
        }
    }
}

//Explosion Handling
var explosions = [];
function Explosion (x, y, radius, duration) {
    this.x = x;
    this.y = y;
    this.r = radius;
    this.currentD = 0;
    this.maxD = duration;
}
    
function explosionHandler () {
    explosions.forEach(expl => {
        if (gameState == "running" || gameState == "dead") {expl.currentD += 1;}
        circle(expl.x, expl.y, expl.r*(expl.currentD/expl.maxD), "orange");
        
        if (expl.currentD > expl.maxD) {
            explosions.splice(explosions.indexOf(expl), 1);
        }
    });
}

function artilleryStrike (x, shellCount, timeSpacing, speed, explosionRadius, damage, damageRadius, spread) {
    for (i = 0; i < shellCount; i++) {
        let xPos = x+spread*rand(-1, 1);
        //x, y, angle, vel, eR, damage, damageRadius, delay
        shells.push(new Shell (xPos, 0, -pi/2, speed, explosionRadius, damage, damageRadius, timeSpacing*i));
    }
}

function playerAtrillery () {
    if (artilleryCooldown <= 0) {
        artilleryMode = true;
        atrilleryCooldown = 100;
    }
}    
    
    
//Buttons--------------------------------------------------------------------------------------------------------------
//Draw all enabled buttons
function drawButtons () {
    buttons.forEach(button => {
        if (button.enabled) {
            button.drawFunction();
        }
    });
}

//Button constructor
function Button (x, y, width, height, enabled, event, drawFunction) {
    this.x = x;
    this.y = y;
    this.w = width;
    this.h = height;
    this.enabled = enabled;
    this.event = event;
    this.drawFunction = drawFunction;
}

function drawCenterRestart () {    
    //drawing the game over button box
    ctx.fillStyle = "white";
    ctx.fillRect(w/2-290, h/2-60, 290*2, 120);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 5;
    ctx.strokeRect(w/2-290, h/2-60, 290*2, 120);
    
    //drawing the game over text
    ctx.font = "bold 100px Courier New";
    ctx.fillStyle = "red";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", w/2, h/2);
    
    //drawing the restart button box
    ctx.fillStyle = "darkgray";
    ctx.fillRect(w/2-130, h/2+60, 130*2, 70);
    ctx.strokeStyle = "black";
    ctx.strokeRect(w/2-130, h/2+60, 130*2, 70);
    
    //drawing the restart text
    ctx.font = "bold 50px Courier New";
    ctx.fillStyle = "gray";
    ctx.textAlign = "center";
    ctx.fillText("Restart", w/2, h/2+60+35);
}

function drawBottomRightPause () {
    //drawing pause button rectangle
    ctx.fillStyle = "darkgray";
    ctx.fillRect(w-80, h-80, 70, 70);
    ctx.lineWidth = 5;
    ctx.strokeStyle = "black";
    ctx.strokeRect(w-80, h-80, 70, 70);
    ctx.fillStyle = "white";

    //draw pause button
    ctx.fillRect(w-65, h-70, 15, 50);
    ctx.fillRect(w-40, h-70, 15, 50);
}
    
function drawBottomRightRestart () {
    //drawing pause button rectangle
    ctx.fillStyle = "darkgray";
    ctx.fillRect(w-280, h-80, 270, 70);
    ctx.lineWidth = 5;
    ctx.strokeStyle = "black";
    ctx.strokeRect(w-280, h-80, w-270, 70);
    
    ctx.font = "bold 50px Courier New";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.fillText("Restart", w-270/2-10, h-45);
}

function drawBottomLeftMenu () {
    //drawing the menu button box
    ctx.fillStyle = "darkgray";
    ctx.fillRect(10, h-80, 300, 70);
    ctx.lineWidth = 5;
    ctx.strokeStyle = "black";
    ctx.strokeRect(10, h-80, 300, 70);

    //drawing the menu text
    ctx.font = "bold 50px Courier New";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.fillText("Main Menu", 160, h-45);
}

function drawCenterPlay () {
    //drawing play button rectangle
    ctx.fillStyle = "darkgray";
    ctx.fillRect(w/2-200, h/2-150, 400, 110);
    ctx.lineWidth = 5;
    ctx.strokeStyle = "black";
    ctx.strokeRect(w/2-200, h/2-150, 400, 110);
    
    //drawing play text
    ctx.font = "bold 100px Courier New";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Play", w/2-50, h/2-95);
    
    //drawing play triangle
    ctx.fillStyle = "white";
    ctx.strokeStyle = "black";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(w/2+170, h/2-95);
    ctx.lineTo(w/2+90, h/2-140);
    ctx.lineTo(w/2+90, h/2-50);
    ctx.lineTo(w/2+170, h/2-95);
    ctx.lineTo(w/2+90, h/2-140);
    ctx.fill();
    ctx.stroke();
}

function drawRightDiff () {
    ctx.fillStyle = "lightgray";
    ctx.strokeStyle = "black";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(w/2+100, h/2-15);
    ctx.lineTo(w/2+100, h/2+35);
    ctx.lineTo(w/2+140, h/2+10);
    ctx.lineTo(w/2+100, h/2-15);
    ctx.fill();
    ctx.stroke();
}

function drawLeftDiff () {
    ctx.fillStyle = "lightgray";
    ctx.strokeStyle = "black";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(w/2-100, h/2-15);
    ctx.lineTo(w/2-100, h/2+35);
    ctx.lineTo(w/2-140, h/2+10);
    ctx.lineTo(w/2-100, h/2-15);
    ctx.fill();
    ctx.stroke();
}

function drawRightSkin () {
    ctx.fillStyle = "lightgray";
    ctx.strokeStyle = "black";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(w/2+100, h/2+75);
    ctx.lineTo(w/2+100, h/2+125);
    ctx.lineTo(w/2+140, h/2+100);
    ctx.lineTo(w/2+100, h/2+75);
    ctx.fill();
    ctx.stroke();
}

function drawLeftSkin () {
    ctx.fillStyle = "lightgray";
    ctx.strokeStyle = "black";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(w/2-100, h/2+75);
    ctx.lineTo(w/2-100, h/2+125);
    ctx.lineTo(w/2-140, h/2+100);
    ctx.lineTo(w/2-100, h/2+75);
    ctx.fill();
    ctx.stroke();
}

function drawAtrillery () {
    //drawing artillery button rectangle
    ctx.fillStyle = "darkgray";
    ctx.fillRect(10, h-80, 70, 70);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 5;
    ctx.strokeRect(10, h-80, 70, 70);

    //drawing artillery button crosshairs
    ctx.strokeStyle = "red";
    ctx.beginPath();
    ctx.moveTo(10+70/2, h-75);
    ctx.lineTo(10+70/2, h-15);
    ctx.moveTo(15, h-10-70/2);
    ctx.lineTo(75, h-10-70/2);
    ctx.arc(10+70/2, h-10-70/2, 70/4, 0, pi*2, false);
    ctx.stroke();

    //drawing cooldown box
    ctx.fillStyle = "black";    
    ctx.globalAlpha = 0.7;
    ctx.fillRect(10, h-10, 70, -70*artilleryCooldown);
    ctx.globalAlpha = 1;
}

function drawCenterPausedResume () {
    //drawing the restart button box
    ctx.fillStyle = "darkgray";
    ctx.fillRect(w/2-230, h/2-60, 230*2, 120);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 5;
    ctx.strokeRect(w/2-230, h/2-60, 230*2, 120);
    
    //drawing the restart text
    ctx.font = "bold 100px Courier New";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.fillText("Résumé", w/2, h/2);
    
    bottomRightRestart.enabled = true; //VERY ANNOYINGLY MOVED HERE AS OTHERWISE INSTANTLY RESTARTS FROM CLICK PERSISTENCE (I THINK)
}

function drawShellSelectHE () {
    //drawing HE button rectangle
    ctx.fillStyle = "darkgray";
    ctx.fillRect(10, 100, 70, 70);
    if (shellType == "HE") {ctx.strokeStyle = "gray";}
    else{ctx.strokeStyle = "black";}
    ctx.lineWidth = 5;
    ctx.strokeRect(10, 100, 70, 70);
    
    //drawing orage star
    ctx.fillStyle = "orange";
    ctx.beginPath();
    ctx.moveTo(45+30, 135);
    for (a = 0; a < pi*2; a += pi/4) {
        ctx.lineTo(45+Math.cos(a)*30, 135+Math.sin(a)*30);
        ctx.lineTo(45+Math.cos(a+pi/8)*15, 135+Math.sin(a+pi/8)*15);
    }
    ctx.fill();
    
    //drawing shell
    circle(45, 135, 10, "black");
}

function drawShellSelectAP () {
    let h = 180
    //drawing AP button rectangle
    ctx.fillStyle = "darkgray";
    ctx.fillRect(10, h, 70, 70);
    if (shellType == "AP") {ctx.strokeStyle = "gray";}
    else{ctx.strokeStyle = "black";}
    ctx.lineWidth = 5;
    ctx.strokeRect(10, h, 70, 70);
    
    //drawing speed lines
    ctx.strokeStyle = "gray";
    ctx.beginPath()
    ctx.moveTo(45, h+26);
    ctx.lineTo(20, h+55);
    ctx.moveTo(45, h+35);
    ctx.lineTo(20, h+65);
    ctx.moveTo(45, h+44);
    ctx.lineTo(28, h+65);
    ctx.stroke();
    
    //drawing shell
    circle(45, h+35, 10, "black");
}

function drawPausedMute () {
    //drawing mute button rectangle
    ctx.fillStyle = "darkgray";
    ctx.fillRect(10, 80, 70, 70);
    
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.moveTo(20, 100);
    ctx.lineTo(20, 130);
    ctx.lineTo(30, 130);
    ctx.lineTo(45, 140);
    ctx.lineTo(45, 90);
    ctx.lineTo(30, 100);
    ctx.lineTo(20, 100);
    ctx.fill();
    
    ctx.strokeStyle = "red";
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.arc(25, 115, 40, -pi/5, pi/5, false);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(25, 115, 30, -pi/5, pi/5, false);
    ctx.stroke();
    
    if (mute) {
        ctx.strokeStyle = "red";
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(10, 150)
        ctx.lineTo(80, 80)
        ctx.stroke();
    }
    
    ctx.strokeStyle = "black";
    ctx.lineWidth = 5;
    ctx.strokeRect(10, 80, 70, 70);
}

function drawMenuMute () {
    //drawing mute button rectangle
    ctx.fillStyle = "darkgray";
    ctx.fillRect(10, 10, 70, 70);
    
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.moveTo(20, 30);
    ctx.lineTo(20, 60);
    ctx.lineTo(30, 60);
    ctx.lineTo(45, 70);
    ctx.lineTo(45, 20);
    ctx.lineTo(30, 30);
    ctx.lineTo(20, 30);
    ctx.fill();
    
    ctx.strokeStyle = "red";
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.arc(25, 45, 40, -pi/5, pi/5, false);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(25, 45, 30, -pi/5, pi/5, false);
    ctx.stroke();
    
    if (mute) {
        ctx.strokeStyle = "red";
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(10, 80)
        ctx.lineTo(80, 10)
        ctx.stroke();
    }
    
    ctx.strokeStyle = "black";
    ctx.lineWidth = 5;
    ctx.strokeRect(10, 10, 70, 70);
}

function drawMenuControls () {
    //drawing controls button rectangle
    ctx.fillStyle = "darkgray";
    ctx.fillRect(10, 90, 70, 70);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 5;
    ctx.strokeRect(10, 90, 70, 70);
    
    ctx.drawImage(keyboard, 15, 95, 60, 60)
}

function drawMenuBack () {
    //drawing back button rectangle
    ctx.fillStyle = "darkgray";
    ctx.fillRect(10, h-80, 70, 70);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 5;
    ctx.strokeRect(10, h-80, 70, 70);
    
    ctx.fillStyle = "lightgray";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(65, h-80+10);
    ctx.lineTo(65, h-80+60);
    ctx.lineTo(25, h-80+35);
    ctx.lineTo(65, h-80+10);
    ctx.fill();
    ctx.stroke();
}
    
    
//HUD------------------------------------------------------------------------------------------------------------------     
//Drawing the HUD for the player
function overlay () {
    if (gameState == "running" || gameState == "paused") {
        let player = tanks[0]; //safe as if this isnt accurate only if gamestate is dead
        hudValues.health = Math.max(player.health, 0); //prevent health bar from displaying negative health
        hudValues.ammo = player.ammo; //Getting new ammo values
        hudValues.score = Math.round(score);
    }
    
    //Drawing the artillery crosshairs
    if (artilleryMode && gameState != "dead") {
        ctx.lineWidth = 5;        
        ctx.strokeStyle = "red";
        ctx.fillStyle = "red";
        
        ctx.globalAlpha = 0.3;
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1;
        
        ctx.beginPath();
        ctx.moveTo(mouseX, 0);
        ctx.lineTo(mouseX, h);
        ctx.moveTo(0, mouseY);
        ctx.lineTo(w, mouseY);
        ctx.stroke();
    }

    //drawing the shot power indicator on the right side of the screen
    ctx.font = "bold 23px Courier New";
    ctx.textAlign = "center";
    ctx.fillStyle = "black";
    ctx.fillText("Power", w-45, 88);
    line(w-45, 110, w-45, 410, "black", 5);
    line(w-70, 110, w-20, 110, "black", 5);
    line(w-70, 260, w-20, 260, "black", 5);
    line(w-70, 410, w-20, 410, "black", 5);
    let y = 260
    if (power > 1) {y = 110;}
    else if (power < 1) {y = 410;}
    ctx.fillStyle = "white";
    ctx.beginPath()
    ctx.arc(w-45, y, 10, 0, pi*2, false);
    ctx.fill();
    ctx.stroke();
    
    //Dimming the background
    if (gameState == "paused" || gameState == "dead") {
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1;
    }    
        
    //Drawing gray background bar at the top of the screen
    ctx.fillStyle = "darkgray";
    ctx.fillRect(0, 0, w, 70)
    ctx.strokeStyle = "black";
    ctx.lineWidth = 5;
    ctx.strokeRect(2.5, 2.5, w-5, 70-5);
    
    //draw the base of the hp bar
    ctx.fillStyle = "gray";
    ctx.fillRect(220, 20, 250, 30);
    //draw the actual hp indication
    ctx.fillStyle = "red";
    ctx.fillRect(220, 20, 250*(hudValues.health/200), 30);

    //draw the box and details arount the hp bar
    line(220, 10, 220, 60, "black", 5);
    line(220+250, 10, 220+250, 60, "black", 5);
    ctx.strokeRect(220, 20, 250, 30);
    
    //drawing the text in the hud
    ctx.fillStyle = "black";
    ctx.textBaseline = "middle";
    ctx.textAlign = "start";
    ctx.font = "bold 50px Courier New";
    ctx.fillText("Health", 20, 35);
    ctx.fillText("Ammo:" + hudValues.ammo, w-260, 35);
    
    ctx.textAlign = "left";
    ctx.fillText("Score:" + hudValues.score, w/2-60, 35);
}

//Loading screen to draw while images are loading
function loadingScreen () {
    ctx.fillStyle = "darkgray";
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = "black";
    
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";
    ctx.font = "75px Courier New";
    ctx.fillText("Loading...", w/2, h/2);
    
    //Black border around the screen
    ctx.lineWidth = 10;
    ctx.strokeStyle = "black";
    ctx.strokeRect(0, 0, w, h);
}

//Drawing details on the menu screen (Play button is a button obviously)
function drawMenu () {
    //Black border around the screen
    ctx.lineWidth = 10;
    ctx.strokeStyle = "black";
    ctx.strokeRect(0, 0, w, h);
    
    if (displayControls) {
        ctx.globalAlpha = 0.8
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1
        
        ctx.drawImage(keybinds, w/2-1096/2, 0, 1096, 550);
    }
    else{
    //High score in the center top
    ctx.fillStyle = "black";
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";
    ctx.font = "bold 50px Courier New";
    ctx.fillText("High Score: " + Math.round(topScore), w/2, 50);
    
    //Difficulty selector below play button
    ctx.lineWidth = 10;
    ctx.fillStyle = "gray";
    ctx.strokeRect(w/2-150, h/2-25, 300, 70);
    ctx.fillRect(w/2-150, h/2-25, 300, 70);
    ctx.font = "bold 70px Courier New";
    ctx.fillStyle = "black";
    ctx.fillText(diffIndex[currentDiff], w/2, h/2+10)
    
    //Coin indicator in top right
    ctx.drawImage(coin, w-80, 10, 70, 70)
    ctx.textAlign = "end";
    ctx.fillText(coins, w-85, 45);
    
    //Tip display along the botton
    ctx.textAlign = "center";
    ctx.font = "bold 50px Courier New";
    ctx.fillText(tips[tipIndex], w/2, h-35, w-20);
    
    //Skin selector box & tank
    ctx.fillStyle = "gray";
    ctx.strokeRect(w/2-150, h/2+65, 300, 70);
    ctx.fillRect(w/2-150, h/2+65, 300, 70);
    
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(w/2, h/2+100-12);
    ctx.lineTo(w/2+Math.cos(0.15)*60, h/2+100-12-Math.sin(0.15)*60);
    ctx.stroke();
    ctx.drawImage(skins[skinIndex], w/2-60, h/2+100-30, 120, 60);
        
    line(45, 125, 115, 175, "black", 3.5);
    ctx.fillStyle = "black";
    ctx.textAlign = "start";
    ctx.font = "bold 35px Courier New";
    ctx.fillText("Controls", 120, 175);
    }
}
    
    
//Logic----------------------------------------------------------------------------------------------------------------    
function imgObject (name, x, y, width, height, xVel, yVel, gravity, img, lifetime) {
    this.name = name;
    this.x = x;
    this.y = y;
    this.w = width;
    this.h = height;
    this.xVel = xVel;
    this.yVel = yVel;
    this.gravity = gravity;
    this.img = img;
    this.lifetime = lifetime;
    this.counter = 0;
}
function txtObject (name, x, y, width, height, xVel, yVel, gravity, text, color, lifetime) {
    this.name = name;
    this.x = x;
    this.y = y;
    this.w = width;
    this.h = height;
    this.xVel = xVel;
    this.yVel = yVel;
    this.gravity = gravity;
    this.text = text;
    this.color = color;
    this.lifetime = lifetime;
    this.counter = 0;
}  

function objectHandler () {
    objects.forEach(object => {
        if (gameState != "paused") {
            if (object.lifetime != null) {
                object.counter++;
            }
            if (object.counter >= object.lifetime) {
                objects.splice(objects.indexOf(object), 1);
            }
            
            if (object.gravity) {object.yVel += objFg;}
            object.x += object.xVel;        
            object.y += object.yVel;

            if (object.y+object.h/2 > terrain[Math.round(object.x)] && object.gravity) {
                object.y = terrain[Math.round(object.x)]-object.h/2;
                object.yVel = 0;
            }
        }

        if (object.constructor.name == "imgObject") {
            ctx.drawImage(object.img, object.x-object.w/2, object.y-object.h/2, object.w, object.h);
        } else {
            ctx.globalAlpha = 1-object.counter/object.lifetime;
            ctx.fillStyle = object.color;
            ctx.font = "bold "+object.h+"px Courier New";
            ctx.textAlign = "center";
            ctx.fillText(object.text, object.x, object.y-object.h/2)
            ctx.globalAlpha = 1;
        }
    });
}

function gameLogic (){
    for (i = 0; i < sounds.length; i++) {
        if (sounds[i].ended) {
            sounds.splice(sounds.indexOf(sounds[i]), 1); //Removes sound from the array when it is finished
        }
    }
}

function toggleDisplayControls () {
    displayControls = !displayControls;
    menuBack.enabled = displayControls;
    
    centerPlay.enabled = !displayControls;
    menuMute.enabled = !displayControls;
    diffLeft.enabled = !displayControls;
    diffRight.enabled = !displayControls;
    skinLeft.enabled = !displayControls;
    skinRight.enabled = !displayControls;
    controlsMenu.enabled = !displayControls;
}

function incSkin () {
    skinIndex = Math.min(skinIndex+1, 2);
    setCookie("selectedSkin", skinIndex);
}

function decSkin () {
    skinIndex = Math.max(skinIndex-1, 0);
    setCookie("selectedSkin", skinIndex);
}

function incDiff () {
    currentDiff = Math.min(currentDiff+1, 2);
    setCookie("difficulty", currentDiff);
}

function decDiff () {
    currentDiff = Math.max(currentDiff-1, 0);
    setCookie("difficulty", currentDiff);
}

function selectHE () { //Has to be two seperate functions as they're called through buttons
    shellType = "HE";
}

function selectAP () {
    shellType = "AP";
}

function getRandomShellType () {
    let shellType = "HE";
    if (Math.random() > 0.5) {shellType = "AP";}
    return shellType;
}

function setHighScore () {
    if (score > topScore) {
        topScore = score;
        setCookie("highScore", topScore)
    }
    score = 0;
}

function toggleMute () {
    mute = !mute;
    setCookie("muted", mute);
    if (mute) {
        for (i = 0; i < sounds.length; i++) {sounds[i].pause();}
    }
}

function playAudio (audioSrc) {
    if (!mute) {
        let audio = new Audio(audioSrc);
        audio.play();
        sounds.push(audio);
    }
}

//Click and button handling
function clickHandler (event) {
    let clickX = event.offsetX;
    let clickY = event.offsetY;
    
    //Performing button functions when clicked on and enabled
    buttons.forEach(button => {
        if (button.enabled) {
            if (clickX > button.x && clickX < button.x+button.w && clickY > button.y && clickY < button.y+button.h) {
                button.event();
            }
        }
    });
    
    //Calling artillery on mouse click
    if (artilleryMode && gameState == "running" && clickY < h-80) {
        //x, shellCount, timeSpacing, speed, explosionRadius, damage, damageRadius, spread
        artilleryStrike(clickX, 10, 10, 1000, 20, 50, 50, 150);
        artilleryMode = false;
        artilleryCooldown = 1;
    }
}
$('canvas').click(clickHandler);
    
    
//Misc-----------------------------------------------------------------------------------------------------------------
//Restart Gameplay
function restart () {
    coins += Math.round(score);
    setCookie("coins", coins)
    setHighScore();
        
    centerRestart.enabled = false;
    bottomRightPause.enabled = true;
    bottomRightRestart.enabled = false;
    bottomLeftMenu.enabled = false;
    centerPlay.enabled = false;
    artillery.enabled = true;
    centerPausedResume.enabled = false;
    shellSelectHE.enabled = true;
    shellSelectAP.enabled = true;
    pausedMute.enabled = false;
    menuMute.enabled = false;
    diffLeft.enabled = false;
    diffRight.enabled = false;
    skinLeft.enabled = false;
    skinRight.enabled = false;
    controlsMenu.enabled = false;
    
    gameState = "running";
    dayTime = 1-Math.min(Math.random()+Math.random(), 1);
    tMomentum = 0;
    tY = h/2;
    terrain = [];
    for (x = 0; x <= (w+100); x++) {
        generatePoint(false);
    }
    clouds = [];
    for(c = 0; c < 5; c++) {
        generateCloud(true, false);
    } 
    hudValues = {health:null, ammo:null};   
    shells = [];
    particles = [];
    objects = [];
    power = 1;
    artilleryCooldown = 0;
    artilleryMode = false;
    tanks = [
        new playerTank(100, 175, 100, 50, 0, 0, 15, maxPlayerHealth, skins[skinIndex]),
        new aiTank(w-100, 175, 100, 50, w-200, 50, 100, getRandomShellType(), aiTankImg)
    ];
}

//Switch to and from menu screen
function toggleMenu () {
    if (gameState == "menu") { //Starting Gameplay
        restart();
    }
    else {
        gameState = "menu"; //Returning to Menu
        centerRestart.enabled = false;
        bottomRightPause.enabled = false;
        bottomLeftMenu.enabled = false;
        centerPlay.enabled = true;
        artillery.enabled = false;
        centerPausedResume.enabled = false;
        shellSelectHE.enabled = false;
        shellSelectAP.enabled = false;
        pausedMute.enabled = false;
        menuMute.enabled = true;
        diffLeft.enabled = true;
        diffRight.enabled = true;
        skinLeft.enabled = true;
        skinRight.enabled = true;
        controlsMenu.enabled = true;
        bottomRightRestart.enabled = false;
        
        coins += Math.round(score);
        setCookie("coins", coins)
        setHighScore();
        
        clouds = [];
        for (c = 0; c < 7; c++) {
            generateCloud(true, true);
        }
        
        tipIndex += 1;
        if (tipIndex >= tips.length) {tipIndex = 0;}
        setCookie("tipindex", tipIndex);
    }
}

//Pause and Unpause
function pause () {
    if (gameState == "paused") { //Resuming Gameplay
        gameState = "running";
        
        artillery.enabled = true;
        bottomLeftMenu.enabled = false;
        centerPausedResume.enabled = false;
        pausedMute.enabled = false;
        shellSelectHE.enabled = true;
        shellSelectAP.enabled = true;
        bottomRightPause.enabled = true;
        bottomLeftMenu.enabled = false;
        bottomRightRestart.enabled = false;
    }
    else {
        gameState = "paused"; //Pausing the game
        
        artillery.enabled = false;
        centerPausedResume.enabled = true;
        pausedMute.enabled = true;
        shellSelectHE.enabled = false;
        shellSelectAP.enabled = false;
        bottomRightPause.enabled = false;
        bottomLeftMenu.enabled = true;
//      bottomRightRestart.enabled = true; //Moved to centerPausedResume as otherwise click persistence causes instant restart
    }
}

//Called when the player dies (here so its not buried)
function death () {
    gameState = "dead";
    
    centerRestart.enabled = true;
    bottomLeftMenu.enabled = true;
    bottomRightPause.enabled = false;
    artillery.enabled = false;
    shellSelectHE.enabled = false;
    shellSelectAP.enabled = false;
}

    
//Particles------------------------------------------------------------------------------------------------------------
//Particle Constructor
function Particle (x, y, angle, vel, color, size, lifetime, gravity) {
    this.x = x;
    this.y = y;
    this.Vx = Math.cos(-angle)*vel;
    this.Vy = Math.sin(-angle)*vel;
    this.color = color;
    this.size = size;
    this.maxLife = lifetime;
    this.life = 0;
    this.gravity = gravity;
}

//Drawing particles and performing physics on them
function particleRenderer () {
    particles.forEach(particle => {
        ctx.fillStyle = particle.color;
        let size = particle.size;
        ctx.fillRect(particle.x-size/2, particle.y-size/2, size, size);
        
        if (gameState != "paused") {
            particle.x += particle.Vx;
            if (particle.gravity) {particle.Vy -= Fg/500;}
            particle.y += particle.Vy;
            
            particle.life++;
            if(particle.life > particle.maxLife || particle.y > terrain[Math.round(particle.x)]) { //Removing the particle when it hits the ground or its lifetime expires
                particles.splice(particles.indexOf(particle), 1);
            }
        }
    });
}
    
    
//Tanks----------------------------------------------------------------------------------------------------------------
function playerTank (x, y, width, height, elevation, reload, ammo, health, img) {
    this.x = x;
    this.y = y;
    this.w = width;
    this.h = height;
    this.elv = elevation;
    this.reload = reload;
    this.ammo = ammo;
    this.health = health;
    this.img = img;
}  

function aiTank (x, y, width, height, pathingX, reload, health, shellType, img) {
    this.x = x;
    this.y = y;
    this.w = width;
    this.h = height;
    this.pathX = pathingX;
    this.reload = reload;
    this.health = health;
    this.shellType = shellType;
    this.img = img;
}

function tankHandler () {
    tanks.forEach(tank => {
        let width = tank.w/2;
        let height = tank.h/2
        let x = tank.x;
        let y = 200-height;
        let a = 0;

        let angleOffset = Math.atan(height/(width)); //Calc angle offset from tanks angle, used to get bottom left and right coords
        let dist = Math.sqrt((width)*(width) + height*height); //Calc the distance from the center x and y to those same bottom left and right coords

        let leftX = x-width+8; //Offset left and right in by 8 to account for the curve of the track
        let leftY = y+height;

        let rightX = x+width-8;
        let rightY = y+height;

        let leftMaxY = h; let leftMaxX = null;
        let rightMaxY = h; let rightMaxX = null;
        for (terrainX = Math.round(leftX); terrainX < x-3; terrainX++) { //Find the highest points in the terrain on the left side of the tank
            let pointY = terrain[terrainX];
            if (pointY < leftMaxY) {
                leftMaxY = pointY;
                leftMaxX = terrainX;
            }
        }
        for (terrainX = Math.round(x+3); terrainX <= rightX; terrainX++) { //Find the highest points in the terrain on the right side of the tank
            let pointY = terrain[terrainX];
            if (pointY < rightMaxY) {
                rightMaxY = pointY;
                rightMaxX = terrainX;
            }
        }

        let deltaX = rightMaxX - leftMaxX;
        let deltaY = rightMaxY - leftMaxY;
        a = -Math.atan2(deltaY, deltaX); //Calculate the angle of the tank based off of the highest point on the right and left
        let m = (rightMaxY - leftMaxY)/(rightMaxX - leftMaxX);

        for (inc = 0; inc < h; inc++) { //using a for loop instead of a while purely so the game doesn't freeze if this fails, instead the tank will temporarily dissapear to the bottom of the screen
            y += 1

            leftX = x-Math.cos(a+angleOffset)*dist; //Calc the bottom left and right coords mentioned earlier to calculate y intercept of a line parallel to the bottom of the tank
            leftY = y+Math.sin(a+angleOffset)*dist;
            rightX = x+Math.cos(a-angleOffset)*dist;
            rightY = y-Math.sin(a-angleOffset)*dist;

            let b = leftY-m*leftX; //Calculate the y intercept of the previously mentioned line

            let bool = false;
            for (testX = leftX; testX <= rightX; testX++) { //Loop along the bottom of the track checking if any of it collides with the terrain
                if (m*testX+b > terrain[Math.round(testX)]) {
                    bool = true;
                }
            }
            if (bool) {break;}
        }
        y += 10;
        tank.y = y;

        if (tank.reload > 0 && gameState != "paused") {tank.reload -= 1;}
        
        var bx1 = x+Math.cos(a+pi/2)*10;
        var by1 = y-Math.sin(a+pi/2)*10;
        
        if (tank.constructor.name == "playerTank") {
            objects.forEach(object => {
                if (Math.abs(object.x-x) < width && Math.abs(object.y-y) < height && object.name == "healthCrate") {
                    tank.health = Math.min(tank.health+75, maxPlayerHealth);
                    objects.splice(objects.indexOf(object), 1);
                }
            });
            
            let innacuracy = 0;
            
            if (gameState != "paused") {
                if (Math.random() > 0.8) {
                    let color = "gray";
                    if (Math.random() > tank.health/200) {
                        color = "rgb("+rand(200, 255)+","+rand(0, 165)+",0"
                    }
                    particles.push(new Particle(x-Math.cos(a-0.4)*(width-15), y+Math.sin(a-0.4)*(width-15), a+pi/2+rand(-0.13, 0.13), rand(2, 3), color, 7.5, rand(15, 25), false));
                }
                
                if (keys["left"] && x > width+speed) {
                    tank.x -= speed*difficulty[currentDiff]["speedModifier"];    
                    innacuracy += (Math.random()-0.5);
                    particles.push(new Particle(rightX+Math.cos(a)*2, rightY-Math.sin(a)*2+3, a+pi/4, Math.random()*5, "saddlebrown", 3, 5, true));
                }
                else if (keys["right"]) {
                    if (x < w/2) {
                        tank.x += speed*difficulty[currentDiff]["speedModifier"];
                    }
                    else{
                        for (t = 0; t < speed; t++) {
                            terrain.shift();
                            generatePoint(true);
                        }
                        shells.forEach(shell => { //Move shells in the air when the player moves terrain towards them
                            shell.xPos -= speed;
                        });
                        objects.forEach(object => {
                            object.x -= speed;
                        });
                        tanks.forEach(aitank => { //Move ai tanks when the player moves terrain towards them
                            if (aitank.constructor.name == "aiTank" && aitank.x > aitank.w+10) {
                                aitank.x -= speed;
                            }
                        });
                    }
                    innacuracy += (Math.random()-0.5);
                    particles.push(new Particle(leftX-Math.cos(a)*2, leftY+Math.sin(a)*2+3, a+3*pi/4, Math.random()*5, "saddlebrown", 3, 5, true));
                }

                if (keys["up"] && tank.elv < pi+0.07) {
                    if(keys["shift"]){tank.elv += 0.03;}
                    else{tank.elv += 0.01;}
                }
                if (keys["down"] && tank.elv > -0.07) {
                    if(keys["shift"]){tank.elv -= 0.03;}
                    else{tank.elv -= 0.01;}
                }
            }
            
            //Calculate the coords for the barrel, 1st set is center of the tank, second is the end of barrel
            var bx2 = bx1+Math.cos(a+tank.elv)*width;
            var by2 = by1-Math.sin(a+tank.elv)*width;
            let x1 = bx2+Math.cos(a+tank.elv)*10;
            let y1 = by2-Math.sin(a+tank.elv)*10;

            if (keys["space"] && tank.reload <= 0 && tank.ammo > 0 && gameState != "paused") { //Fire shell for player
                //x, y, angle, vel, eR, damage, damageRadius, delay
                if (shellType == "HE") {shells.push(new Shell(x1, y1, a+tank.elv+innacuracy, 700*power, 20, 35, 80, 0));}
                if (shellType == "AP") {shells.push(new Shell(x1, y1, a+tank.elv+innacuracy, 1000*power, 10, 75, 5, 0));}
                
                playAudio(tankFireSrc);
                
                tank.reload = 75; //Governs reload duration, higher = longer
                tank.ammo--;
            }
        }
        else{ //Handle the ai tank movement and firing
            let elevation = 3*pi/4; //Set default elevation for the AI tank
            
            if (tanks[0].constructor.name == "playerTank") { //Check if the player is still alive
                if (Math.random() > 0.8) {
                    let color = "gray";
                    if (Math.random() > tank.health/100) {
                        color = "rgb("+rand(200, 255)+","+rand(0, 165)+",0"
                    }
                    particles.push(new Particle(x+Math.cos(a+0.4)*(width-15), y-Math.sin(a+0.4)*(width-15), a+pi/2+rand(-0.13, 0.13), rand(2, 3), color, 7.5, rand(15, 25), false));
                }
                
                if (tank.reload > 15 && getDist(x, 0, tank.pathX, 0) > 10 && gameState != "paused") {
                    if (x - tank.pathX < 0 && x < w-width-100) {
                        tank.x += speed/1.5;
                        particles.push(new Particle(leftX-Math.cos(a)*2, leftY+Math.sin(a)*2+3, a+3*pi/4, Math.random()*5, "saddlebrown", 3, 5, true));
                    }
                    else if (x - tank.pathX > 0 && x > width+10) {
                        tank.x -= speed/1.5;
                        particles.push(new Particle(rightX+Math.cos(a)*2, rightY-Math.sin(a)*2+3, a+pi/4, Math.random()*5, "saddlebrown", 3, 5, true));
                    }
                }

                if (tanks[0].x > tank.x) {
                    elevation = pi/4;
                }
            }

            var bx2 = bx1+Math.cos(elevation)*width;
            var by2 = by1-Math.sin(elevation)*width;
            let x1 = bx2+Math.cos(elevation)*10;
            let y1 = by2-Math.sin(elevation)*10;

            if (tank.reload <= 0 && gameState == "running") { //Fire shell for ai
                let x2 = tanks[0].x;
                let y2 = tanks[0].y;
                let Xd = Math.abs(x2-x1);
                let Yd = y2-y1;
                let t = Math.sqrt((-2*(Xd+Yd))/Fg);
                let Vy = Xd/t;
                let Vx = Vy;
                let Vo = Math.sqrt(Vx*Vx+Vy*Vy);
                if (tank.shellType == "HE") {shells.push(new Shell(x1, y1, elevation, Vo, 20, 40, 40, 0));}
                if (tank.shellType == "AP") {shells.push(new Shell(x1, y1, elevation, Vo, 10, 75, 5, 0));}
                
                playAudio(tankFireSrc);
                
                tank.reload = 100; //Governs reload duration, higher = longer
                tank.pathX = w/2+Math.random()*(w/2)
            }
        }
                
        if (tank.health <= 0) {
            if (tank.constructor.name == "aiTank") {
                tanks[0].ammo += 10; 
                score += 10;
            }
            else {
                death();
            }
            playAudio(tankExplodeSrc);
            explosions.push(new Explosion(x, y, width*2, 5));
            craterMath(x, y, width*2, 50);
            for (a = 0; a <= pi; a += pi/20) {
                particles.push(new Particle(x, y, a, Math.random()*30, "black", 7.5, 15, true));
            }
            tanks.forEach(tank2 => {
                if (tank2 != tank) {
                    let damage = Math.max(200-getDist(tank2.x, tank2.y, x, y), 0);
                    if (damage > 0) {
                        tank2.health -= damage; //Damage tanks based on proximity to explosion
                        objects.push(new txtObject("damage", tank2.x+tank2.w/2, tank2.y-20, 50, 50, 4, -4, false, "-" + Math.ceil(damage), "red", 25));
                    }
                }
            });
            
            tanks.splice(tanks.indexOf(tank), 1);
        }
        
        //Drawing gun barrel
        ctx.lineWidth = 5;
        ctx.strokeStyle = "black";
        ctx.beginPath();
        ctx.moveTo(bx1, by1);
        ctx.lineTo(bx2, by2);
        ctx.stroke();

        //Drawing the tank itself
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(-a);
        ctx.drawImage(tank.img, -width, -height, width*2, height*2);
        ctx.restore();
    });
}
    
    
//Terrain--------------------------------------------------------------------------------------------------------------
//Generating Terrain
function generatePoint (addAI) {
    tMomentum += (Math.random())*2-1;
    tMomentum = Math.min(tMomentum, 5);
    tMomentum = Math.max(tMomentum, -5);
    
    tY += tMomentum/10;
    if (tY < 200) {
        tY = 200;
        tMomentum += 1;
    }
    if (tY > h-100) {
        tY = h-100;
        tMomentum -= 1;
    }
    
    terrain.push(tY);
    if (addAI) {
        forceSpawnTank++;
        forceSpawnCrate++;
        score += 0.01;
        if (Math.round(Math.random()*1200) == 69 || forceSpawnTank >= difficulty[currentDiff]["forceSpawn"]) {
            forceSpawnTank = 0;
            tanks.push(new aiTank(w-50, 175, 100, 50, w-200, 50, 100, getRandomShellType(), aiTankImg));
        }
        if (Math.round(Math.random()*difficulty[currentDiff]["crateChance"]) == 69 || forceSpawnCrate >= 7000) {
            forceSpawnCrate = 0;
            objects.push(new imgObject("healthCrate", rand(w/2, w), -25, 50, 50, 0, 0, true, healthCrate));
        }
    }
}    

//Drawing Terrain
function drawTerrain () {
    ctx.fillStyle = grd;
    
    ctx.strokeStyle = "forestgreen";
    ctx.lineWidth = 10;
    
    ctx.beginPath(); //Everything is offset down to account for the line width of the grass so tank doesn't sink in
    ctx.moveTo(0, terrain[0]+offset);
    for (i = 1; i < terrain.length; i++) { //Loop through terrain heightmap and draw grass and dirt in one path
        ctx.lineTo(i, terrain[i]+offset);
    }
    ctx.stroke();
    ctx.lineTo(w, terrain[terrain.length-1]+offset);
    ctx.lineTo(w, h);
    ctx.lineTo(0, h);
    ctx.lineTo(0, terrain[0]+offset);
    ctx.fill();
}

//Generating Clouds
function generateCloud (initial, fullscreen) {
    let cloud = [w+150+r, Math.random()*(h/3)+75];
    if (fullscreen) {cloud[1] = Math.random()*h}
    if (initial) {cloud[0] = Math.random()*w;}
    for (i = 0; i <= pi; i += pi/(10)) {
        cloud.push(Math.cos(i)*(Math.random()*50+100));
        cloud.push(Math.sin(i)*(Math.random()*25+50));
    }
    cloud.push(rand(200, 255));
    clouds.push(cloud);
}
    
function getSkyColor () {
    let scale = Math.max(1-dayTime, 0.8);
    return [Math.round(135*scale), Math.round(206*scale), Math.round(235*scale)];
}    
    
//Drawing Background and Clouds
function drawBackground () {
    if (gameState != "menu") {
        let color = getSkyColor();
        ctx.fillStyle = "rgb("+color[0]+","+color[1]+","+color[2]+")";
    } else {
        ctx.fillStyle = "skyblue";
    }
    ctx.fillRect(0, 0, w, h);
    
    ctx.fillStyle = "white";
    for (c = 0; c < clouds.length; c++) {
        let cloud = clouds[c];
        let x = cloud[0];
        let y = cloud[1];
        let color = cloud[cloud.length-1];
        ctx.fillStyle = "rgb("+color+","+color+","+color+")";
        ctx.beginPath(); 
        ctx.moveTo(x+cloud[2], y+r);
        for (i = 4; i < cloud.length-3; i += 2) {
            ctx.lineTo(x+cloud[i], y-cloud[i+1]);
        }    
        ctx.lineTo(x+cloud[cloud.length-3], y+r);
        ctx.fill();

        for (i = 2; i < cloud.length-1; i += 2) {
            ctx.beginPath(); 
            ctx.arc(x+cloud[i], y-cloud[i+1], r, 0, pi*2, false);
            ctx.fill();
        }
    }
    if (gameState != "paused") {
        for (c = 0; c < clouds.length; c++) {
            if (clouds[c][0] < -(150+r)) {
                clouds.splice(c, 1);
                generateCloud(false, gameState == "menu");
            }
            else{
                clouds[c][0]--;
            }
        }
    }
}
    
//Darkening screen at night
function daytimeOverlay () {
    ctx.fillStyle = "black";
    ctx.globalAlpha = dayTime*0.8;
    ctx.fillRect(0, 0, w, h);
    ctx.globalAlpha = 1;
}

    
//Main Game Loop-------------------------------------------------------------------------------------------------------   
function run () {
    if (skins[skinIndex].complete && skins[skinIndex].width != 0) { //Returns true once the image is done loading, need to scale with multiple textures
        if (gameState != "menu") {
            gameLogic();
            drawBackground();
            objectHandler();
            tankHandler();
            drawTerrain();
            shellHandler();  
            particleRenderer();
            daytimeOverlay();
            explosionHandler();
            overlay();
            drawButtons();
        }
        else {
            drawBackground();  
            drawMenu();
            drawButtons();
        }
    }
    else{
        loadingScreen();
    }
}
setInterval(run, loop);
    
</script>
</html>
